<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Dynamic Music Player</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Music Player">
    <link rel="manifest" href="/manifest.json">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            text-align: center;
            margin: 20px;
            max-width: 800px;
            margin: 0 auto;
            background: linear-gradient(to bottom, #f0f0f0, #d0d0d0);
            color: #333;
        }

        #currentSong {
            margin: 20px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        #currentTitle {
            margin-bottom: 10px;
        }

        #currentCover {
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        #audio {
            width: 90%;
            max-width: 500px;
            margin: 10px 0;
        }

        .controls {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin: 10px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .controls button {
            margin: 5px;
            padding: 10px 15px;
            font-size: 16px;
            border: none;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: background 0.3s;
        }

        .controls button:hover {
            background: rgba(255, 255, 255, 0.8);
        }

        .controls button.active {
            background: rgba(0, 0, 0, 0.1);
        }

        input[type="range"] {
            width: 90%;
            max-width: 500px;
            margin: 10px;
        }

        #timeDisplay {
            font-size: 14px;
            margin: 5px;
            width: 100%;
        }

        #songSearch {
            width: 90%;
            max-width: 500px;
            padding: 10px;
            margin: 15px 0;
            border: none;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.5);
        }

        #playlist {
            margin-top: 20px;
            max-height: 50vh;
            overflow-y: auto;
            padding: 10px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            text-align: left;
        }

        #playlist li {
            cursor: pointer;
            padding: 10px;
            list-style: none;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #playlist li:last-child {
            border-bottom: none;
        }

        #playlist li.active {
            background: rgba(0, 0, 0, 0.1);
            font-weight: bold;
        }

        #playlist li .song-name {
            flex: 1;
        }

        #playlist li a {
            text-decoration: none;
            color: #333;
            padding: 5px;
        }

        textarea {
            width: 90%;
            max-width: 500px;
            height: 100px;
            margin-top: 20px;
            padding: 10px;
            border: none;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.5);
        }

        button {
            margin: 10px;
            padding: 10px 20px;
            border: none;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: background 0.3s;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.8);
        }

        input[type="file"] {
            margin: 10px;
        }

        #predefinedPlaylists {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }

        #predefinedPlaylists button {
            margin: 5px;
        }
    </style>
</head>

<body>
    <h2>My Music Player</h2>

    <div id="currentSong">
        <h3 id="currentTitle">No song selected</h3>
        <img id="currentCover" src="https://placehold.co/300?text=No+Cover" width="300" height="300" alt="Album Cover">
    </div>

    <audio id="audio" controls preload="metadata"></audio>

    <div class="controls">
        <button onclick="prevSong()">‚èÆ Prev</button>
        <button onclick="playPause()">‚ñ∂Ô∏è/‚è∏ Play/Pause</button>
        <button onclick="nextSong()">‚è≠ Next</button>
        <button id="shuffleBtn" onclick="toggleShuffle()">üîÄ Shuffle</button>
        <br>
        <input type="range" id="seekbar" value="0" step="0.1">
        <div id="timeDisplay">0:00 / 0:00</div>
    </div>

    <input type="text" id="songSearch" placeholder="Search songs..." oninput="searchSongs()">

    <ul id="playlist"></ul>

    <h3>Predefined Playlists</h3>
    <div id="predefinedPlaylists">
        <!-- Add buttons for each JSON file here, e.g.: -->
        <button onclick="loadPredefined('m/hayedeh.json')">Hayedeh</button>
        <button onclick="loadPredefined('m/ebi.json')">Ebi</button>
        <button onclick="loadPredefined('m/siavash.json')">Siavash Ghomayshi</button>
        <button onclick="loadPredefined('m/moein.json')">Moein</button>
        <button onclick="loadPredefined('m/shahram-solati.json')">Shahram Solati</button>
        <!-- Add more as you create new JSON files -->
    </div>

    <h3>Paste Playlist Array or Upload JSON</h3>
    <textarea id="playlistInput"
        placeholder='Example: ["https://example.com/song1.mp3", "https://example.com/song2.mp3"] or array of objects'></textarea><br>
    <button onclick="savePlaylist()">Save & Load from Paste</button>
    <input type="file" id="playlistFile" accept=".json">
    <button onclick="loadFromFile()">Load from File</button>

    <script>
        const audio = document.getElementById('audio');
        const seekbar = document.getElementById('seekbar');
        const playlistUl = document.getElementById('playlist');
        const timeDisplay = document.getElementById('timeDisplay');
        const currentTitle = document.getElementById('currentTitle');
        const currentCover = document.getElementById('currentCover');
        const shuffleBtn = document.getElementById('shuffleBtn');

        let songs = [];
        let currentIndex = 0;
        let shuffleMode = false;
        let shuffleOrder = [];
        let positionUpdateInterval;

        // Helper to get image type from URL
        function getImageType (url) {
            if (url.endsWith('.png')) return 'image/png';
            return 'image/jpeg';
        }

        // Human-readable display name
        function getDisplayName (song) {
            if (!song || !song.link) return "Unknown Song";
            if (song.artist && song.song) return `${song.artist} - ${song.song}`;
            if (song.title) return song.title;
            let name = decodeURIComponent(song.link.split('/').pop().split('?')[0]);
            name = name.replace(/\.[^/.]+$/, ''); // remove extension
            name = name.replace(/_/g, ' ');
            return name.trim();
        }

        // For MediaMetadata
        function getMetadataInfo (song) {
            if (!song || !song.link) return { title: "Unknown Song", artist: "Unknown Artist" };
            const display = getDisplayName(song);
            if (display.includes(' - ')) {
                const parts = display.split(' - ', 2);
                return { title: parts[1].trim(), artist: parts[0].trim() };
            }
            return { title: display, artist: song.artist || "Unknown Artist" };
        }

        function formatTime (seconds) {
            if (isNaN(seconds)) return "0:00";
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${m}:${s}`;
        }

        function shuffleArray (array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function toggleShuffle () {
            shuffleMode = !shuffleMode;
            shuffleBtn.classList.toggle('active', shuffleMode);
            if (shuffleMode) {
                shuffleOrder = Array.from({ length: songs.length }, (_, i) => i);
                const currentPos = shuffleOrder.indexOf(currentIndex);
                if (currentPos !== -1) shuffleOrder.splice(currentPos, 1);
                shuffleArray(shuffleOrder);
                shuffleOrder.unshift(currentIndex);
            }
        }

        function buildPlaylist () {
            playlistUl.innerHTML = '';
            songs.forEach((song, index) => {
                const li = document.createElement('li');
                const nameSpan = document.createElement('span');
                nameSpan.className = 'song-name';
                nameSpan.textContent = getDisplayName(song);
                nameSpan.onclick = () => loadSong(index, true);
                const downloadA = document.createElement('a');
                downloadA.href = song.link;
                downloadA.download = `${getDisplayName(song)}.mp3`;
                downloadA.textContent = '‚¨á';
                li.appendChild(nameSpan);
                li.appendChild(downloadA);
                playlistUl.appendChild(li);
            });
            updateActiveHighlight();
            searchSongs(); // re-apply current search filter
        }

        function updateActiveHighlight () {
            Array.from(playlistUl.children).forEach((li, i) => {
                li.classList.toggle('active', i === currentIndex);
            });
        }

        function searchSongs () {
            const filter = document.getElementById('songSearch').value.toLowerCase();
            Array.from(playlistUl.children).forEach(li => {
                const text = li.textContent.toLowerCase();
                const isCurrent = li.classList.contains('active');
                li.style.display = (text.includes(filter) || isCurrent) ? '' : 'none';
            });
        }

        function loadSong (index, autoplay = true) {
            currentIndex = index;
            const song = songs[currentIndex];
            audio.src = song.hq_link || song.link;
            const info = getMetadataInfo(song);
            currentTitle.textContent = `${info.title} - ${info.artist}`;
            currentCover.src = song.photo || song.thumbnail || `https://placehold.co/300?text=${encodeURIComponent(info.title)}`;
            currentCover.alt = info.title;
            updateMediaSession(song);

            // Reset seekbar until we know duration
            seekbar.max = 1;
            seekbar.value = 0;
            timeDisplay.textContent = `0:00 / 0:00`;

            if (autoplay) {
                audio.play().catch(e => console.log("Play prevented:", e));
            }
            updateActiveHighlight();
            searchSongs(); // make sure current song is visible
            localStorage.setItem('currentIndex', currentIndex);
        }

        function playPause () {
            if (audio.paused) audio.play();
            else audio.pause();
        }

        function nextSong () {
            if (shuffleMode) {
                const currentPos = shuffleOrder.indexOf(currentIndex);
                if (currentPos < shuffleOrder.length - 1) {
                    currentIndex = shuffleOrder[currentPos + 1];
                } else {
                    // Reshuffle all
                    shuffleOrder = Array.from({ length: songs.length }, (_, i) => i);
                    shuffleArray(shuffleOrder);
                    currentIndex = shuffleOrder[0];
                }
            } else {
                currentIndex = (currentIndex + 1) % songs.length;
            }
            loadSong(currentIndex);
        }

        function prevSong () {
            if (shuffleMode) {
                const currentPos = shuffleOrder.indexOf(currentIndex);
                if (currentPos > 0) {
                    currentIndex = shuffleOrder[currentPos - 1];
                } else {
                    // Loop to end
                    currentIndex = shuffleOrder[shuffleOrder.length - 1];
                }
            } else {
                currentIndex = (currentIndex - 1 + songs.length) % songs.length;
            }
            loadSong(currentIndex);
        }

        function updateMediaSession (song) {
            if ('mediaSession' in navigator) {
                const info = getMetadataInfo(song);
                let artwork = [
                    { src: 'https://placehold.co/96', sizes: '96x96', type: 'image/png' },
                    { src: 'https://placehold.co/128', sizes: '128x128', type: 'image/png' },
                    { src: 'https://placehold.co/256', sizes: '256x256', type: 'image/png' },
                    { src: 'https://placehold.co/512', sizes: '512x512', type: 'image/png' }
                ];
                if (song.photo) {
                    const type = getImageType(song.photo);
                    artwork = [
                        { src: song.thumbnail || song.photo, sizes: '96x96', type },
                        { src: song.photo_240 || song.photo, sizes: '128x128', type },
                        { src: song.photo_240 || song.photo, sizes: '256x256', type },
                        { src: song.photo, sizes: '512x512', type }
                    ];
                }

                navigator.mediaSession.metadata = new MediaMetadata({
                    title: info.title,
                    artist: info.artist,
                    album: 'My Playlist',
                    artwork
                });

                const defaultSkipTime = 10;

                const actionHandlers = [
                    ['play', () => audio.play()],
                    ['pause', () => audio.pause()],
                    ['previoustrack', prevSong],
                    ['nexttrack', nextSong],
                    ['stop', () => audio.pause()],
                    ['seekbackward', (details) => {
                        const skipTime = details.seekOffset || defaultSkipTime;
                        audio.currentTime = Math.max(audio.currentTime - skipTime, 0);
                        updatePositionState();
                    }],
                    ['seekforward', (details) => {
                        const skipTime = details.seekOffset || defaultSkipTime;
                        audio.currentTime = Math.min(audio.currentTime + skipTime, audio.duration);
                        updatePositionState();
                    }],
                    ['seekto', (details) => {
                        if (details.fastSeek && 'fastSeek' in audio) {
                            audio.fastSeek(details.seekTime);
                        } else {
                            audio.currentTime = details.seekTime;
                        }
                        updatePositionState();
                    }]
                ];

                for (const [action, handler] of actionHandlers) {
                    try {
                        navigator.mediaSession.setActionHandler(action, handler);
                    } catch (error) {
                        console.log(`MediaSession action "${action}" not supported:`, error);
                    }
                }

                navigator.mediaSession.playbackState = audio.paused ? 'paused' : 'playing';
            }
        }

        function updatePositionState () {
            if ('setPositionState' in navigator.mediaSession) {
                navigator.mediaSession.setPositionState({
                    duration: audio.duration || 0,
                    playbackRate: audio.playbackRate,
                    position: audio.currentTime || 0
                });
            }
        }

        // Playback state and interval for notification sync
        audio.addEventListener('play', () => {
            if ('mediaSession' in navigator) {
                navigator.mediaSession.playbackState = 'playing';
            }
            // Workaround interval for bug
            clearInterval(positionUpdateInterval);
            positionUpdateInterval = setInterval(updatePositionState, 1000);
        });

        audio.addEventListener('pause', () => {
            if ('mediaSession' in navigator) {
                navigator.mediaSession.playbackState = 'paused';
            }
            clearInterval(positionUpdateInterval);
        });

        audio.addEventListener('loadedmetadata', () => {
            updatePositionState();  // Initial sync after metadata
        });

        // Seekbar + time display (for in-app UI)
        audio.addEventListener('timeupdate', () => {
            if (!isNaN(audio.duration)) {
                seekbar.max = audio.duration;
                seekbar.value = audio.currentTime;
                timeDisplay.textContent = `${formatTime(audio.currentTime)} / ${formatTime(audio.duration)}`;
                // No need to call updatePositionState here; interval handles it for notification
            }
        });

        seekbar.addEventListener('input', () => {
            audio.currentTime = seekbar.value;
            updatePositionState();
        });

        // Auto-advance to next song
        audio.addEventListener('ended', () => {
            clearInterval(positionUpdateInterval);  // Clear on end
            nextSong();
        });

        // Save progress every 5 seconds (efficient, only when something to save)
        setInterval(() => {
            if (songs.length > 0 && !isNaN(audio.currentTime)) {
                localStorage.setItem('currentIndex', currentIndex);
                localStorage.setItem('currentTime', audio.currentTime);
            }
        }, 5000);

        // Also save on page unload (mobile browsers sometimes kill intervals)
        window.addEventListener('beforeunload', () => {
            if (songs.length > 0) {
                localStorage.setItem('currentIndex', currentIndex);
                localStorage.setItem('currentTime', audio.currentTime);
            }
        });

        function processPlaylist (arr) {
            try {
                if (!Array.isArray(arr)) throw new Error();

                // Normalize to array of objects
                songs = arr.map(item => {
                    if (typeof item === 'string') {
                        return { link: item };
                    } else if (typeof item === 'object' && item.link) {
                        return item;
                    } else {
                        throw new Error('Invalid item in array');
                    }
                });

                // Start fresh with a new playlist
                localStorage.removeItem('currentIndex');
                localStorage.removeItem('currentTime');
                localStorage.setItem('songs', JSON.stringify(songs));

                currentIndex = 0;
                shuffleMode = false;
                shuffleBtn.classList.remove('active');
                shuffleOrder = [];
                buildPlaylist();
                if (songs.length > 0) loadSong(0);
            } catch (e) {
                alert('Invalid JSON ‚Äì must be an array of URLs or objects with at least "link".\nExample: ["url1.mp3"] or [{"link":"url1.mp3", "artist":"Artist", "song":"Song", "photo":"cover.jpg"}]');
            }
        }

        function savePlaylist () {
            const input = document.getElementById('playlistInput').value.trim();
            if (input) {
                const arr = JSON.parse(input);
                processPlaylist(arr);
            }
        }

        function loadFromFile () {
            const fileInput = document.getElementById('playlistFile');
            const file = fileInput.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const content = e.target.result.trim();
                    const arr = JSON.parse(content);
                    processPlaylist(arr);
                };
                reader.readAsText(file);
            } else {
                alert('Please select a JSON file.');
            }
        }

        function loadPredefined (file) {
            fetch(file)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to load playlist');
                    }
                    return response.json();
                })
                .then(arr => processPlaylist(arr))
                .catch(e => {
                    console.error(e);
                    alert('Error loading predefined playlist: ' + e.message);
                });
        }

        // ‚îÄ‚îÄ‚îÄ Page load ‚Äì resume last session ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        window.onload = () => {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw.js').catch(console.error);
            }

            const savedSongs = localStorage.getItem('songs');
            if (savedSongs) {
                songs = JSON.parse(savedSongs);
                // Upgrade old format if necessary
                if (songs.length > 0 && typeof songs[0] === 'string') {
                    songs = songs.map(link => ({ link }));
                    localStorage.setItem('songs', JSON.stringify(songs)); // Update storage to new format
                }
                buildPlaylist();

                const savedIndex = localStorage.getItem('currentIndex');
                const savedTime = localStorage.getItem('currentTime');

                if (savedIndex !== null && songs.length > 0) {
                    currentIndex = Math.min(parseInt(savedIndex, 10), songs.length - 1);
                    loadSong(currentIndex, false); // load without immediate play

                    if (savedTime !== null) {
                        const targetTime = parseFloat(savedTime);

                        const resume = () => {
                            if (audio.readyState >= 2) { // HAVE_CURRENT_DATA
                                audio.currentTime = targetTime;
                                updatePositionState();
                                audio.play().catch(() => { }); // resume playback
                            }
                        };

                        audio.addEventListener('canplay', resume, { once: true });
                        audio.addEventListener('loadedmetadata', resume, { once: true });
                    } else {
                        audio.play().catch(() => { });
                    }
                }
            }

            // Initial mediaSession setup (will be overwritten when a song loads)
            updateMediaSession({});
            updatePositionState();
        };
    </script>
</body>

</html>